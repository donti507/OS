import matplotlib.pyplot as plt
from typing import List, Tuple


class DiskRequest:
    def __init__(self, track, arrival_time=0, deadline=float('inf')):
        self.track = track
        self.arrival_time = arrival_time
        self.deadline = deadline


class DiskScheduler:
    def __init__(self, total_tracks: int = 200):
        self.total_tracks = total_tracks
        self.current_position = 53
        self.requests = []

    def calculate_seek_time(self, from_track, to_track): # we calculated the seek time here
        return abs(to_track - from_track)



# this code is for visualize
    def plot_movements(self, algorithm_name: str, movements: List[int], total_movement: int):

        plt.figure(figsize=(12, 8))
        plt.plot(range(len(movements)), movements, 'b-o', label="Track Visited")

        for i in range(1, len(movements)):
            plt.arrow(i - 1, movements[i - 1], 0.8, movements[i] - movements[i - 1],
                      head_width=0.3, head_length=3, fc='red', ec='red', length_includes_head=True)

        plt.title(f'{algorithm_name} Disk Scheduling\nTotal head movement: {total_movement} tracks')
        plt.xlabel('Request Sequence')
        plt.ylabel('Track Number')
        plt.grid(True)
        plt.legend()
        plt.show()



    def fcfs(self) -> Tuple[List[int], int]:

        movements = [self.current_position]
        total_movement = 0
        current_pos = self.current_position

        for request in self.requests:
            pos = request.track
            movements.append(pos)
            total_movement += self.calculate_seek_time(current_pos, pos)
            current_pos = pos

        self.plot_movements("FCFS", movements, total_movement)
        return movements, total_movement



    def sstf(self) -> Tuple[List[int], int]:

        movements = [self.current_position]
        total_movement = 0
        current_pos = self.current_position
        remaining_requests = self.requests.copy()

        while remaining_requests:
            closest = min(remaining_requests, key=lambda x: self.calculate_seek_time(current_pos, x.track))
            pos = closest.track
            movements.append(pos)
            total_movement += self.calculate_seek_time(current_pos, pos)
            current_pos = pos
            remaining_requests.remove(closest)

        self.plot_movements("SSTF", movements, total_movement)
        return movements, total_movement



    def scan(self) -> Tuple[List[int], int]:

        movements = [self.current_position]
        total_movement = 0
        current_pos = self.current_position
        remaining_requests = sorted(self.requests, key=lambda x: x.track)

        greater = [r for r in remaining_requests if r.track >= current_pos]
        lesser = [r for r in remaining_requests if r.track < current_pos]

        # i have used reversed here to move to the left zero and starting the pointing again
        for request in reversed(lesser):
            pos = request.track
            movements.append(pos)
            total_movement += self.calculate_seek_time(current_pos, pos)
            current_pos = pos

        # if it didnt find zero then go to the end of the track
        if current_pos != 0:
            movements.append(0)
            total_movement += self.calculate_seek_time(current_pos, 0)
            current_pos = 0


        for request in greater:  #now to the greater value again
            pos = request.track
            movements.append(pos)
            total_movement += self.calculate_seek_time(current_pos, pos)
            current_pos = pos

        self.plot_movements("SCAN (Left-first)", movements, total_movement)
        return movements, total_movement



    def c_scan(self) -> Tuple[List[int], int]:
        movements = [self.current_position]
        total_movement = 0
        current_pos = self.current_position
        remaining_requests = sorted(self.requests, key=lambda x: x.track)

# here making the requests separate
        greater = [r for r in remaining_requests if r.track >= current_pos]
        lesser = [r for r in remaining_requests if r.track < current_pos]


        for request in greater:   ##here its greater, so it moves to right
            pos = request.track
            movements.append(pos)
            total_movement += abs(current_pos - pos)
            current_pos = pos

        if lesser:
            end_track = 200
            movements.append(end_track)
            total_movement += abs(current_pos - end_track)
            current_pos = end_track

            movements.append(0)
            total_movement += abs(current_pos - 0)  # Adds 200, not 199
            current_pos = 0


            for request in lesser:  #moving to right if its smaller than the initial point 53
                pos = request.track
                movements.append(pos)
                total_movement += abs(current_pos - pos)
                current_pos = pos

        self.plot_movements("C-SCAN", movements, total_movement)
        return movements, total_movement




    def edf(self) -> Tuple[List[int], int]:

        movements = [self.current_position]
        total_movement = 0
        current_pos = self.current_position
        remaining_requests = self.requests.copy()


        while remaining_requests:

            next_request = min(remaining_requests, key=lambda x: x.deadline)
            pos = next_request.track
            movements.append(pos)
            total_movement += self.calculate_seek_time(current_pos, pos)
            current_pos = pos
            remaining_requests.remove(next_request)

        self.plot_movements("EDF (Corrected)", movements, total_movement)
        return movements, total_movement



    def fd_scan(self) -> Tuple[List[int], int]:

        movements = [self.current_position]
        total_movement = 0
        current_pos = self.current_position

        remaining_requests = sorted(self.requests, key=lambda x: x.track)

        feasible_requests = [r for r in remaining_requests if
                             self.calculate_seek_time(current_pos, r.track) <= r.deadline]

        greater = [r for r in feasible_requests if r.track >= current_pos]
        lesser = [r for r in feasible_requests if r.track < current_pos]

        for request in greater:
            movements.append(request.track)
            total_movement += self.calculate_seek_time(current_pos, request.track)
            current_pos = request.track

        for request in reversed(lesser):
            movements.append(request.track)
            total_movement += self.calculate_seek_time(current_pos, request.track)
            current_pos = request.track

        self.plot_movements("FD-SCAN", movements, total_movement)
        return movements, total_movement









def main():
    scheduler = DiskScheduler(200)

    scheduler.requests = [
        DiskRequest(98, deadline=25),
        DiskRequest(183, deadline=30),
        DiskRequest(37, deadline=35),
        DiskRequest(122, deadline=40),
        DiskRequest(14, deadline=45),
        DiskRequest(124, deadline=50),
        DiskRequest(65, deadline=55),
        DiskRequest(67, deadline=60),
        DiskRequest(152, deadline=65),
        DiskRequest(42, deadline=70),
        DiskRequest(89, deadline=75),
        DiskRequest(132, deadline=80),
        DiskRequest(17, deadline=85),
        DiskRequest(95, deadline=90),
        DiskRequest(177, deadline=95),
        DiskRequest(28, deadline=100),
        DiskRequest(169, deadline=105),
        DiskRequest(56, deadline=110),
        DiskRequest(143, deadline=115),
        DiskRequest(78, deadline=120)
    ]


    print("FCFS:")
    movement, sequence = scheduler.fcfs()
    print(f"Total head movement: {sequence} tracks\n")

    print("SSTF:")
    movement, sequence = scheduler.sstf()
    print(f"Total head movement: {sequence} tracks\n")

    print("SCAN:")
    movement, sequence = scheduler.scan()
    print(f"Total head movement: {sequence} tracks\n")

    print("C-SCAN:")
    movement, sequence = scheduler.c_scan()
    print(f"Total head movement: {sequence} tracks\n")

    print("EDF:")
    movement, sequence = scheduler.edf()
    print(f"Total head movement: {sequence} tracks\n")

    print("FD-SCAN:")
    movement, sequence = scheduler.fd_scan()
    print(f"Total head movement: {sequence} tracks\n")


if __name__ == "__main__":
    main()
